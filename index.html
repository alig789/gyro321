<!DOCTYPE html>
<html lang="en">

<head>


    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,height=device-height,user-scalable=no,initial-scale=1.0">
    <title>Gyroscope</title>
    <link rel="stylesheet" href="style.css">
    <style>
        body { margin: 0; padding-bottom: 3rem; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color:rgb(66, 65, 65) }
        button {
			color: #ffffff;
			background-color: #000000;
			font-size: 19px;
			border: 5px solid rgb(32, 32, 32);
			padding: 15px 50px;
			cursor: pointer;
		}
		button:hover {
			color: #212325;
			background-color: #4b4b4b;
		}
        #info {
            position: absolute;
            top: px;
            width: 100%;
            
            z-index: 100;
            display: block;
        }
        #canvas1{
            position: absolute;
            top: 250px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1 id="id01">ID: N/A</h1>
        <h1 id="id02">Connected Users: N/A</h1>
        <button id="input">iPhone users click here!</button>
        <button id="input2">RESET</button>

        <p></p>

    </div>


    <canvas id="canvas1"></canvas>


    <!-- <script type="text/javascript" src="display.js"></script>-->
    <!--<script type="text/javascript" src="gyroscope.js"></script>-->
    <!--<script type="text/javascript" src="script.js"></script>-->
    <script type="text/javascript" src="/socket.io/socket.io.js"></script>
    <script type="text/javascript" src="three.js"></script>

    <script src="cannon.min.js"></script>











    <script>




        var socket = io();

        var messages = document.getElementById('messages');
        var form = document.getElementById('form');
        var input = document.getElementById('input');

        input.addEventListener('click', function (e) {



            askPermission()




        });

        input2.addEventListener('click', function (e) {

            
            world.remove(marble0[0]);
            scene.remove(marble0[1]);
            marble0 = createMarble(scene, world, 1, 1, 1, 0, 0, 3);
            


        });

        socket.on('new_connect', function (id) {

            const element = document.getElementById("id01");
            element.innerHTML = "ID: " + id;


            gyroObject.num_id = id
            socket.emit('created_gyro', gyroObject, id);

            runGyroscope();

        });


        socket.on('update_count', function (users) {
            const element2 = document.getElementById("id02");
            element2.innerHTML = "Connected Users: " + users;
        });

        socket.on('average_orientation', function (average) {

            average_orientation = average;
        });
        socket.on('marble_info', function (serverMarble_pos,serverMarble_quat) {

            marble_info_pos = serverMarble_pos;
            marble_info_quat = serverMarble_quat;
        });
        socket.on('server_boxes', function (serverBoxes_pos, serverBoxes_scale) {
            
            createBoxes(serverBoxes_pos,serverBoxes_scale);
        });
        socket.on('new_marble', function (xscale) {
            //console.log("HELLOS??DF???");
            myMarble = createMarbleOnly(scene, 1, 0, 0, 3);
            //createMarbleOnly(scene, 4, 4, 4, 4);
        });
        socket.on('pivot_info', function (pivot_rot) {
            //console.log("HELLOS??DF???");
            pivot_info = pivot_rot;
            //createMarbleOnly(scene, 4, 4, 4, 4);
        });
        
        





        screen.orientation.lock("portrait");

        const canvas = document.getElementById('canvas1');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let updateCount = 0;

        class displayCanvas {
            constructor() {
                this.updateCount = 0;
            }
            update() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                //ctx.fillStyle = "white";
                //ctx.fillRect(0, 0, canvas.width, canvas.height);

                //Make it change colors while you tilt the x, y, z
                /*ctx.fillStyle = `rgb(
                        ${Math.floor(255 - Math.abs(gyroObject.x / 2))},
                        ${Math.floor(255 - Math.abs(gyroObject.y))},
                        ${Math.floor(255 - Math.abs(gyroObject.z))}`;
                */
                //ctx.fillRect(0, 0, canvas.width, canvas.height);

                //ctx.fillStyle = "gray";
                ctx.font = "20px Georgia";
                ctx.fillText("Your info:", 10, 20);
                ctx.fillText("x: " + parseInt(gyroObject.x), 10, 50);
                ctx.fillText("y: " + parseInt(gyroObject.y), 10, 80);
                ctx.fillText("z: " + parseInt(gyroObject.z), 10, 110);

                ctx.fillText("Average info:", 10, 140);
                ctx.fillText("x: " + parseInt(average_orientation[0]), 10, 170);
                ctx.fillText("y: " + parseInt(average_orientation[1]), 10, 200);
                ctx.fillText("z: " + parseInt(average_orientation[2]), 10, 230);
                //ctx.fillText("Updates: " + this.updateCount, 10, 260);
                this.updateCount++;

            }


        }


        function askPermission() {   //askPermission is an HTML requirement of iOS
            DeviceOrientationEvent.requestPermission() //This asks for permission (iOS requirement)
            window.addEventListener("deviceorientation", function (event) { //This listens to the phone orientation values
                controller.x = event.alpha;
                controller.y = event.beta;
                controller.z = event.gamma;
            });
        }

        //Android users will have their data automatically working on page load from this one.  It can be removed, the button above should also work.
        if (window.DeviceOrientationEvent) {
            window.addEventListener("deviceorientation", function (event) {
                controller.x = event.alpha;
                controller.y = event.beta;
                controller.z = event.gamma;

            });
        }



        //This is where we are temporarily storing the values.  Each Gyroscope client/Object made from script.js will have it's own x, y, z.


        //This will be the main Gyroscope object, we can initialize it in the main (script.js) if we've confirmed a mobile device.
        //That object can then use the functions within the class below.
        const controller = {
            x: 0,
            y: 0,
            z: 0
        }

        //This will be the main Gyroscope object, we can initialize it in the main (script.js) if we've confirmed a mobile device.
        //That object can then use the functions within the class below.
        class Gyroscope {
            constructor(num_id) {

                this.num_id = num_id;
                this.x = controller.x
                this.y = controller.y
                this.z = controller.z
            }

            //We will call this function recursively from script.  It will return the device orientation data.
            update() {

                gyroObject.x = controller.x
                gyroObject.y = controller.y
                gyroObject.z = controller.z
                socket.emit('gyro_update', this.num_id, this.x, this.y, this.z);
            }



            //Now that we have the X,Y,Z values, we need to send the data to the server and the client webpage will be finished.


        }
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.background = new THREE.Color(0x707070);
        camera.position.z = 10;
        //camera.position.set(0, 5, 10);
        //camera.rotation.set(-0.2, 0, 0);

        function createBoxes(serverBoxes_pos,serverBoxes_scale) {
            for (let i = 0; i < serverBoxes_pos.length; i++) {
                console.log(serverBoxes_scale[i]);
                createWall2(scene, serverBoxes_pos[i], serverBoxes_scale[i]);
            }
        }


        function createCube(scene, xscale, yscale, zscale, xpos, ypos, zpos) {

            const geometry = new THREE.BoxGeometry(xscale, yscale, zscale);


            const texture = new THREE.TextureLoader().load("textures/cobble.png");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;


            const material = new THREE.MeshBasicMaterial({ map: texture });

            const cube1 = new THREE.Mesh(geometry, material);
            cube1.position.set(xpos, ypos, zpos);
            pivot.add(cube1);
            //scene.add(cube1);
            //return cube1;

        }
        function createWall2(scene, pos,scale) {

            const geometry = new THREE.BoxGeometry(scale.x,scale.y,scale.z);


            const texture = new THREE.TextureLoader().load("textures/brick.png");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;


            const material = new THREE.MeshBasicMaterial({ map: texture });

            const cube1 = new THREE.Mesh(geometry, material);
            cube1.position.set(pos.x,pos.y,pos.z);
            pivot.add(cube1);
            //scene.add(cube1);

        }
        function createWall(scene, xscale, yscale, zscale, xpos, ypos, zpos) {

            const geometry = new THREE.BoxGeometry(xscale, yscale, zscale);


            const texture = new THREE.TextureLoader().load("textures/brick.png");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;


            const material = new THREE.MeshBasicMaterial({ map: texture });

            const cube1 = new THREE.Mesh(geometry, material);
            cube1.position.set(xpos, ypos, zpos);
            pivot.add(cube1);
            //scene.add(cube1);

        }
        function createMarbleOnly(scene, xscale, xpos, ypos, zpos) {

            const geometry = new THREE.SphereGeometry(xscale);


            const texture = new THREE.TextureLoader().load("textures/dirt.png");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;


            const material = new THREE.MeshBasicMaterial({ map: texture });

            const sphere1 = new THREE.Mesh(geometry, material);
            sphere1.position.set(xpos, ypos, zpos);
            //pivot.add(cube1);
            scene.add(sphere1);
            return sphere1;

        }
        function createMarble(scene, world, xscale, yscale, zscale, xpos, ypos, zpos) {

            const geometry = new THREE.SphereGeometry(xscale);
            const texture = new THREE.TextureLoader().load("textures/dirt.png");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            const material = new THREE.MeshBasicMaterial({ map: texture });

            const sphere1 = new THREE.Mesh(geometry, material);
            sphere1.useQuaternion = true;
            sphere1.position.set(xpos, ypos, zpos);
            scene.add(sphere1);

            var sphereBody = new CANNON.Body({
                mass: 5, // kg
                position: new CANNON.Vec3(xpos, ypos, zpos), // m
                shape: new CANNON.Sphere(xscale)
            });
            world.addBody(sphereBody);
            //threejsBodies.push(sphere1);
            //cannonjsBodies.push(sphereBody);
            return [sphereBody, sphere1];
            
        }
        function createBox(scene,world, xscale, yscale, zscale, xpos, ypos, zpos) {

            const geometry = new THREE.BoxGeometry(xscale,yscale,zscale);
            const texture = new THREE.TextureLoader().load("textures/wood.png");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            const material = new THREE.MeshBasicMaterial({ map: texture });

            const box1 = new THREE.Mesh(geometry, material);
            box1.useQuaternion = true;
            box1.position.set(xpos, ypos, zpos);
            box1.rotation.x = 0.2
            scene.add(box1);

            var boxBody = new CANNON.Body({
                mass: 0, // kg
                position: new CANNON.Vec3(xpos, ypos, zpos), // m
                shape: new CANNON.Box(new CANNON.Vec3(xscale/2, yscale/2, zscale/2)),
                quaternion: box1.quaternion
            });
            world.addBody(boxBody);
            threejsBodies.push(box1);
            cannonjsBodies.push(boxBody);
            return;


        }
        function createBoxShape(scene, world,body, xscale, yscale, zscale, xpos, ypos, zpos) {

            const geometry = new THREE.BoxGeometry(xscale, yscale, zscale);
            const texture = new THREE.TextureLoader().load("textures/wood.png");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            const material = new THREE.MeshBasicMaterial({ map: texture });

            const box1 = new THREE.Mesh(geometry, material);
            box1.useQuaternion = true;
            box1.position.set(xpos, ypos, zpos);
            box1.rotation.x = 0.1
            pivot.add(box1);

            boxBody = new CANNON.Box(new CANNON.Vec3(xscale/2, yscale/2, zscale/2));
            body.addShape(boxBody, new CANNON.Vec3(xpos, ypos, zpos));
            

            mazeMeshBodies.push(box1);
            //cannonjsBodies.push(boxBody);
            return;


        }
        function createFloor(scene, xscale, yscale, zscale, xpos, ypos, zpos) {


            const geometry = new THREE.BoxGeometry(xscale, yscale, zscale);

            const texture = new THREE.TextureLoader().load("textures/wood.png");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;

            const material = new THREE.MeshBasicMaterial({ map: texture });

            const cube1 = new THREE.Mesh(geometry, material);
            cube1.position.set(xpos, ypos, zpos);
            pivot.add(cube1);
            //scene.add(cube1);


        }

        //AMOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO
        window.addEventListener('DOMContentLoaded', async () => {
            
        });
        //AMOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO


        function degrees_to_radians(degrees) {
            var pi = Math.PI;
            return degrees * (pi / 180);
        }

        //Initialize the Gyroscope object for the mobile user

        let myBoxes = [];
        let threejsBodies = [];
        let cannonjsBodies = [];

        let mazeMeshBodies = [];
        let mazePhysicsBodies = [];
       
        let average_orientation = [0, 0, 0];
        let pivot_pos = [0, 0, 0];
        let pivot_quat = [0, 0, 0, 1];
        let marble_info_pos = null;
        let marble_info_quat = null;
        let gyroObject = new Gyroscope(0);
        let display = new displayCanvas();
        let frameCounter = 0;
        const pivot = new THREE.Group();
        let clock = new THREE.Clock();
        let floorobject = null;
        let pivot_info = 0;

        //const cube = createCube(scene, 1, 1, 1, 0, 0, 0);//cobble block

        //createFloor(scene, 6, 1, 6, 0.5, -1, 0.5);
        //back wall
        /*
         * createWall(scene, 1, 1, 1, 2, 0, -2);
        createWall(scene, 1, 1, 1, 1, 0, -2);
        createWall(scene, 1, 1, 1, 0, 0, -2);
        createWall(scene, 1, 1, 1, -1, 0, -2);



        //right wall
        createWall(scene, 1, 1, 1, 3, 0, 3);
        createWall(scene, 1, 1, 1, 3, 0, 2);
        createWall(scene, 1, 1, 1, 3, 0, 1);
        createWall(scene, 1, 1, 1, 3, 0, 0);
        createWall(scene, 1, 1, 1, 3, 0, -1);
        createWall(scene, 1, 1, 1, 3, 0, -2);


        //left wall
        createWall(scene, 1, 1, 1, -2, 0, 3);
        createWall(scene, 1, 1, 1, -2, 0, 2);
        createWall(scene, 1, 1, 1, -2, 0, 1);
        createWall(scene, 1, 1, 1, -2, 0, 0);
        createWall(scene, 1, 1, 1, -2, 0, -1);
        createWall(scene, 1, 1, 1, -2, 0, -2);

        //front wall
        createWall(scene, 1, 1, 1, -1, 0, 3);
        createWall(scene, 1, 1, 1, 0, 0, 3);
        createWall(scene, 1, 1, 1, 1, 0, 3);
        createWall(scene, 1, 1, 1, 2, 0, 3);
        */
        //CANNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOON

        // Setup our world
        //var world = new CANNON.World();
        //world.gravity.set(0, 0, -9.82); // m/s²

        // Create a sphere
        /*var radius = 1; // m
        var sphereBody = new CANNON.Body({
            mass: 5, // kg
            position: new CANNON.Vec3(0, 0, 10), // m
            shape: new CANNON.Sphere(radius)
        });
        var floorBody = new CANNON.Body({
            mass: 0, // kg
            position: new CANNON.Vec3(0, 0, 0), // m
            shape: new CANNON.Box(new CANNON.Vec3(4, 4, 4))
        });
        world.addBody(sphereBody);
        world.addBody(floorBody);
        
        // Create a plane
        var groundBody = new CANNON.Body({
            mass: 0 // mass == 0 makes the body static
        });
        var groundShape = new CANNON.Plane();
        groundBody.addShape(groundShape);
        world.addBody(groundBody);
        
        var fixedTimeStep = 1.0 / 60.0; // seconds
        var maxSubSteps = 3;
        */
        // Start the simulation loop

        /*
         * var lastTime;
        (function simloop(time) {
            requestAnimationFrame(simloop);
            if (lastTime !== undefined) {
                var dt = (time - lastTime) / 1000;
                world.step(fixedTimeStep, dt, maxSubSteps);
                copyCoords(marble0[1], marble0[0]);
                copyCoords(body, pivot);
                //copyCoords(floor0, floorBody);
            }
            if (cannonjsBodies.length != 0) { 
                //body.quaternion.y += 0.001;

            }

            lastTime = time;
        })();

        */
        function copyCoords(mesh, body_pos,body_quat) {
            mesh.position.x = body_pos.x;
            mesh.position.y = body_pos.y;
            mesh.position.z = body_pos.z;
            mesh.quaternion.x = body_quat.x;
            mesh.quaternion.y = body_quat.y;
            mesh.quaternion.z = body_quat.z;
            mesh.quaternion.w = body_quat.w;
        }
        function copyRot(mesh, body_quat) {

            mesh.quaternion.x = body_quat.x;
            mesh.quaternion.y = body_quat.y;
            mesh.quaternion.z = body_quat.z;
            mesh.quaternion.w = body_quat.w;
        }




        //createBox(scene, world, 5, 5, 1, 0, 0, 0);


        //let marble0 = createMarble(scene, world, 1, 1, 1, 0, 0, 3);
        //floor0 = createBox(scene, 4, 4, 4, 0, 0, 0);
        //CANOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOON


        /*body = new CANNON.Body({
            mass: 0
        });
        
        createWall(scene, 10, 10, 1, 0, 0, 0);
        createWall(scene, 1, 10, 1, 5, 0, 1);
        createWall(scene, 1, 10, 1, -5, 0, 1);
        */
        var myMarble = null;
        //createBoxes(myBoxes);
        //world.addBody(body);
        //var mesh2 = new THREE.BoxGeometry(singleGeometry);
        scene.add(pivot);

        //createMarbleOnly(scene, 2, 0, 0, 1);


        //This is the recursive function that will keep updating the gyroscope and display canvas
        function runGyroscope() {
            gyroObject.update();
            display.update();
            frameCounter++;

            //console.log(cube.rotation.x);
            //copyCoords(myMarble, marble_info);
            
            if (myMarble != null && marble_info_pos != null && marble_info_quat != null) {
                copyCoords(myMarble, marble_info_pos, marble_info_quat);
            }
            copyRot(pivot, pivot_info);
            console.log(pivot.quaternion);

            //camera.position.x = marble0[0].position.x;
            //camera.position.y = marble0[0].position.y;
            pivot.rotation.x = degrees_to_radians(average_orientation[1]);
            pivot.rotation.y = degrees_to_radians(average_orientation[2]);
            //pivot.rotation.x -= 0.001


            renderer.render(scene, camera);
            requestAnimationFrame(runGyroscope);
        }








    </script>
</body>
</html>

